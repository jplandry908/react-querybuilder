import type { Column, Table } from 'drizzle-orm';
import {
  between,
  eq,
  gt,
  gte,
  inArray,
  isNotNull,
  isNull,
  like,
  lt,
  lte,
  ne,
  notBetween,
  notInArray,
  notLike,
  sql,
} from 'drizzle-orm';
import type { RuleProcessor } from 'react-querybuilder';
import { isValidValue, parseNumber, shouldRenderAsNumber, toArray } from 'react-querybuilder';

// const negateIfNotOp = (op: string, sql: SQL) =>
//   op.startsWith('not') || op.startsWith('doesnot') ? not(sql) : sql;

/**
 * Given a Drizzle table config, returns a {@link react-querybuilder!index.RuleProcessor RuleProcessor}
 * for use by {@link react-querybuilder!index.formatQuery formatQuery}.
 *
 * It's probably unnecessary to call this function directly, but rather implicitly from the
 * {@link react-querybuilder!index.RuleGroupProcessor RuleGroupProcessor} generated by
 * {@link generateDrizzleRuleGroupProcessor}.
 */
export const generateDrizzleRuleProcessor =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (table: Table | Record<string, Column<any>>): RuleProcessor =>
    (
      rule,
      // istanbul ignore next
      { preserveValueOrder } = {}
    ) => {
      const { field, operator, value, valueSource } = rule;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const column = table[field as keyof typeof table] as Column<any>;
      const operatorLC = operator.toLowerCase();

      const valueIsField = valueSource === 'field';
      const asFieldOrValue = (v: string) => (valueIsField ? table[v as keyof typeof table] : v);

      // TODO?: istanbul ignore next
      if (!column) return;

      switch (operatorLC) {
        case '=':
          return eq(column, asFieldOrValue(value));
        case '!=':
          return ne(column, asFieldOrValue(value));
        case '>':
          return gt(column, asFieldOrValue(value));
        case '<':
          return lt(column, asFieldOrValue(value));
        case '>=':
          return gte(column, asFieldOrValue(value));
        case '<=':
          return lte(column, asFieldOrValue(value));
        case 'beginswith':
        case 'doesnotbeginwith':
          return (operatorLC === 'doesnotbeginwith' ? notLike : like)(
            column,
            valueIsField ? sql`${asFieldOrValue(value)} || '%'` : `${value}%`
          );
        case 'contains':
        case 'doesnotcontain':
          return (operatorLC === 'doesnotcontain' ? notLike : like)(
            column,
            valueIsField ? sql`'%' || ${asFieldOrValue(value)} || '%'` : `%${value}%`
          );
        case 'endswith':
        case 'doesnotendwith':
          return (operatorLC === 'doesnotendwith' ? notLike : like)(
            column,
            valueIsField ? sql`'%' || ${asFieldOrValue(value)}` : `%${value}`
          );
        case 'null':
          return isNull(column);
        case 'notnull':
          return isNotNull(column);
        case 'in':
        case 'notin': {
          const valueAsArray = toArray(value).map(v => asFieldOrValue(v));
          return operatorLC === 'notin'
            ? notInArray(column, valueAsArray)
            : inArray(column, valueAsArray);
        }
        case 'between':
        case 'notbetween': {
          const valueAsArray = toArray(value);
          if (
            valueAsArray.length >= 2 &&
            isValidValue(valueAsArray[0]) &&
            isValidValue(valueAsArray[1])
          ) {
            let [first, second] = valueAsArray;
            if (
              !valueIsField &&
              shouldRenderAsNumber(first, true) &&
              shouldRenderAsNumber(second, true)
            ) {
              const firstNum = parseNumber(first, { parseNumbers: true });
              const secondNum = parseNumber(second, { parseNumbers: true });
              if (!preserveValueOrder && secondNum < firstNum) {
                const tempNum = secondNum;
                second = firstNum;
                first = tempNum;
              } else {
                first = firstNum;
                second = secondNum;
              }
            } else {
              // istanbul ignore else
              if (valueIsField) {
                first = asFieldOrValue(first);
                second = asFieldOrValue(second);
              }
            }
            return operatorLC === 'notbetween'
              ? notBetween(column, first, second)
              : between(column, first, second);
          }
          return;
        }
        default:
          return;
      }
    };
